# Put the x-axis on a logarithmic scale
plt.xscale('log')


# Show and clean up again
plt.show()
plt.clf()


# change the opacity of bubble (scatter plot)
plt.scatter(x = gdp_cap, y = life_exp, s = np.array(pop) * 2,c=col,alpha=0.8) # s:size,c:color


# add grid lines
after plt.text() -> add particular text for particular point
plt.grid(True)


# Get index of 'germany': ind_ger
ind_ger = countries.index('germany')
# Use ind_ger to print out capital of Germany
print(capitals[ind_ger])


# Print out the keys in europe
print(europe.keys())
# Print out value that belongs to key 'norway'
print(europe['norway'])


           List                  Vs                Dictionary
Select, update and remove: []            Select, update and remove: []
indexed by range of numbers              indexed by unique keys
Collection of values, order matters      Lookup with unique keys


# add things to dictionary
dic_name['new_key'] = corresponding_value

## cars['cars_per_cap']
cars[['cars_per_cap']]
The single bracket version gives a Pandas Series, the double bracket version gives a Pandas DataFrame.

# set the first column as the index
df = pd.read_csv('data.csv', index_col=0)

## loc and iloc
With loc and iloc you can do practically any data selection operation on DataFrames you can think of. 
loc is label-based, which means that you have to specify rows and columns based on their row and column labels. 
iloc is integer index based, so you have to specify rows and columns by their integer index like you did in the previous exercise.


## Not And Or
Notice that not has a higher priority than and and or, it is executed first.


## find the subset 
You can use   cars[cars['drives_right']] to build sel

## enumerate()
for index, area in enumerate(areas) :
    print("room" + str(index) + ": " + str(area))
