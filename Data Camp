# Put the x-axis on a logarithmic scale
plt.xscale('log')


# Show and clean up again
plt.show()
plt.clf()


# change the opacity of bubble (scatter plot)
plt.scatter(x = gdp_cap, y = life_exp, s = np.array(pop) * 2,c=col,alpha=0.8) # s:size,c:color


# add grid lines
after plt.text() -> add particular text for particular point
plt.grid(True)


# Get index of 'germany': ind_ger
ind_ger = countries.index('germany')
# Use ind_ger to print out capital of Germany
print(capitals[ind_ger])


# Print out the keys in europe
print(europe.keys())
# Print out value that belongs to key 'norway'
print(europe['norway'])


           List                  Vs                Dictionary
Select, update and remove: []            Select, update and remove: []
indexed by range of numbers              indexed by unique keys
Collection of values, order matters      Lookup with unique keys


# add things to dictionary
dic_name['new_key'] = corresponding_value

## cars['cars_per_cap']
cars[['cars_per_cap']]
The single bracket version gives a Pandas Series, the double bracket version gives a Pandas DataFrame.

# set the first column as the index
df = pd.read_csv('data.csv', index_col=0)

## loc and iloc
With loc and iloc you can do practically any data selection operation on DataFrames you can think of. 
loc is label-based, which means that you have to specify rows and columns based on their row and column labels. 
iloc is integer index based, so you have to specify rows and columns by their integer index like you did in the previous exercise.


## Not And Or
Notice that not has a higher priority than and and or, it is executed first.


## find the subset 
You can use   cars[cars['drives_right']] to build sel

## enumerate()
for index, area in enumerate(areas) :
    print("room" + str(index) + ": " + str(area))


######## Numpy: np.nditer
loop over 2D Numpy array
for x in np.nditer(my_array):

## Pandas: iterrows
Iterating over a Pandas DataFrame is typically done with the iterrows()
for x,y in name.iterrows():

Write a for loop that iterates over the rows of cars and on each iteration perform two print() calls: 
one to print out the row label and one to print out all of the rows contents. !!!!!!
( how to show the row name and corresponding row contents?)
for lab, row in cars.iterrows() :
    print(lab)
    print(row)

The row data that's generated by iterrows() on every run is a Pandas Series. This format is not very convenient to print out.
Luckily, you can easily select variables from the Pandas Series using square brackets:

for lab, row in brics.iterrows() :
    print(row['country'])
    
## upper the corresponding colum:
row["country"].upper()


Using iterrows() to iterate over every observation of a Pandas DataFrame is easy to understand, 
but not very efficient. On every iteration, you're creating a new Pandas Series.

If you want to add a column to a DataFrame by calling a function on another column, 
the iterrows() method in combination with a for loop is not the preferred way to go. Instead, you'll want to use apply().

##########################################################  
for lab, row in brics.iterrows() :
    brics.loc[lab, "name_length"] = len(row["country"])

brics["name_length"] = brics["country"].apply(len)
############################################################ 

## Pandas: apply
cars["COUNTRY"] = cars["country"].apply(str.upper)


# random generator

np.random.seed(123)
np.random.rand()
 -- consistent between runs
 
 np.random.randint(0,2) # randomly generate 0 or 1
 np.random.randint(a,b) # randomly generater interger between a and b-1
 


# Initialize random_walk
random_walk=[0] # Make a list random_walk that contains the first step, which is the integer 0.

for x in range(100) : # The loop should run 100 times.
    # Set step: last element in random_walk
    step = random_walk[-1] # On each iteration, set step equal to the last element in the random_walk list. You can use the index -1 for this.

    # Roll the dice
    dice = np.random.randint(1,7)

    # Determine next step
    if dice <= 2:
        step = max(step - 1)
    elif dice <= 5:
        step = step + 1
    else:
        step = step + np.random.randint(1,7) # re-run the dice

    # append next_step to random_walk
    random_walk.append(step)

# Print random_walk
print(random_walk)



##  Simulate multiple walks

# initialize and populate all_walks
all_walks = []
for i in range(10) :
    random_walk = [0]
    for x in range(100) :
        step = random_walk[-1]
        dice = np.random.randint(1,7)
        if dice <= 2:
            step = max(0, step - 1)
        elif dice <= 5:
            step = step + 1
        else:
            step = step + np.random.randint(1,7)
        random_walk.append(step)
    all_walks.append(random_walk)
    


############### Data Cleaning

# Strip duration of minutes
ride_sharing['duration_trim'] = ride_sharing['duration'].str.strip("minutes")

# Convert duration to integer
ride_sharing['duration_time'] = ride_sharing["duration_trim"].astype(int)

# Write an assert statement making sure of conversion
assert ride_sharing['duration_time'].dtype == 'int'

# Print formed columns and calculate average ride duration
print(ride_sharing[['duration','duration_trim','duration_time']])
print((ride_sharing['duration_time']).mean())
