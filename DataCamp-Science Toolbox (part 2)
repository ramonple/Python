Python Data Science Toolbox (Part 2)

summary

Create a range object that would produce the values from 10 to 20 using range(). Assign the result to values
values = range(10, 21) --> should be x: y-1






############################################ Course 1: Using iterators in PythonLand ############################################

iterating with a for loop:
for letter in 'DataCamp':
    print (letter)
    
for i in range(4):
    print(i)
    
Iterators vs. iterables
- iterable:
   example" lists, strings, dictionaries, file connections
   An objective with an associated iter() method
   Apply .iter() to an iterable creates an iterator
- iterator:
   produces next value with next()
   
iterating over iterables: next()
word='Da'
it = iter(word)
next(it) -> D
next(it) -> a

iterating at once with *
word = ' Data'
it=iter(word)
print(*it) -> D a t a
-- once you do so, you cannot do it again. For example, you call print(*it) for the second time, nothing will be outputted.

iterating over dictionaries: [ unpack the dictionary, through .item() ]
pythonistas={'hugo':'bown','francis':'castro'}
for key,value in pythonistas.items(): --> unpack them
    print(key,value)
-> francis castro
   hugo bown


iterating over file connections
file = open('file.txt')
it=iter(file)
print(next(it))
--> this is the first line.



# Create a list of strings: flash
flash = ['jay garrick', 'barry allen', 'wally west', 'bart allen']

# Print each list item in flash using a for loop
for person in flash:
    print(person)

# Create an iterator for flash: superhero
superhero = iter(flash)

# Print each item from the iterator
print(next(superhero))
print(next(superhero))
print(next(superhero))
print(next(superhero))



# Create an iterator for range(3): small_value
small_value = iter(range(3))

# Print the values in small_value
print(next(small_value))
print(next(small_value))
print(next(small_value))

# Loop over range(3) and print the values
for num in range(3):
    print(num)


# Create an iterator for range(10 ** 100): googol
googol = iter(range(10 ** 100))



Create a range object that would produce the values from 10 to 20 using range(). Assign the result to values
values = range(10, 21) --> should be x: y-1






Playing with iterators

using enumerate()
enumerate(iterable, start=0)
The enumerate() method adds a counter to an iterable and returns it (the enumerate object).
-- iterable - a sequence, an iterator, or objects that supports iteration
-- start (optional) - enumerate() starts counting from this number. If start is omitted, 0 is taken as start.

avengers =['hawkeye','iron men','thor','quicksilver']
e = enumerator(avengers)
print(type(e))
--> <class 'enumerate'>
# convert enumerate object to list
e_list=list(e)
print(e_list)
---> [(0,'hawkeye'),(1,'iron men'),(2,'thor'),(3,'quicksilver')]



enumerate() and unpack

avengers =['hawkeye','iron men','thor','quicksilver']
for index, value in enumerate(avengers):
    print(index,value)
--> 0 hawkeye
    1 iron men
    2 thor
    3 quicksilver
    

Complete the first for loop by unpacking the tuples generated by calling enumerate() on mutants. 
Use index1 for the index and value1 for the value when unpacking the tuple.
# Unpack and print the tuple pairs
for index1,value1 in enumerate(mutants):
    print(index1, value1)

Complete the second for loop similarly as with the first, but this time change the starting index to start from 1 
by passing it in as an argument to the start parameter of enumerate(). Use index2 for the index and value2 for the value when unpacking the tuple.
# Change the start index
for index2, value2 in enumerate(mutants,1):
    print(index2, value2)
    
    






using zip()
Join two tuples together:
The zip() function takes iterables (can be zero or more), aggregates them in a tuple, and returns it.
zip(*iterables)
can be built-in iterables (like: list, string, dict), or user-defined iterables

avengers =['hawkeye','iron men','thor','quicksilver']
names = ['barton','stark','odinson','maxmoff']
z = zip(avengers,names)
print(type(z))
--> < class 'zip' >
z_list=list(z)
print(z_list)
--> [('hawkeye','barton'),('iron man','stark'),('thor','odinson'),('quicksilver','maximoff')]
for z1,z2 in zip(avengers,names):
    print(z1,z2)
---> hawkeye barton
     iron man stark
     thor odinson
     quicksilver maximoff




# Create a list of tuples: mutant_data
Using zip() with list(), create a list of tuples from the three lists mutants, aliases, and powers (in that order) and assign the result to mutant_data.
mutant_data = list(zip(mutants, aliases, powers))

# Create a zip object using the three lists: mutant_zip
Using zip(), create a zip object called mutant_zip from the three lists mutants, aliases, and powers.
mutant_zip = zip(mutants, aliases, powers)

# Unpack the zip object and print the tuple values
for value1, value2, value3 in mutant_zip:
    print(value1, value2, value3)
    




------------ Chunk 
    
Sometimes, the data we have to process reaches a size that is too much for a computer's memory to handle. This is a common problem faced by data scientists. 
A solution to this is to process an entire data source chunk by chunk, instead of a single go all at once.

Using iterators to load large files into memory

loading data in chunks
- there acan be too much data to hold in memory
- solution: load data in chunks!
- pandas function: pd.read_csv()
- - specify the chunk: chunk_size


Iterating over data

import pandas as pd
result =[]
for chunk in pd.read_csv('data.csv',chunksize=1000):
    result.append(sum(chunk['x']))
total = sum(result)
print(total)

import pandas as pd
total = 0
for chunk in pd.read_csv('data.csv',chunksize=1000):
    total += sum(chunk['x'])
print(total)


    
# Initialize an empty dictionary: counts_dict
counts_dict={}

# Iterate over the 'tweets.csv' file by using a for loop. Use the loop variable chunk and iterate over the call to pd.read_csv() with a chunksize of 10.
for chunk in pd.read_csv('tweets.csv',chunksize = 10):

    # In the inner loop, iterate over the column 'lang' in chunk by using a for loop. Use the loop variable entry.
    for entry in chunk['lang']:
        if entry in counts_dict.keys():
            counts_dict[entry] += 1
        else:
            counts_dict[entry] = 1






Exercise:
Define the function count_entries(), which has 3 parameters. The first parameter is csv_file for the filename, the second is c_size for the chunk size, and the last is colname for the column name.
Iterate over the file in csv_file file by using a for loop. Use the loop variable chunk and iterate over the call to pd.read_csv(), passing c_size to chunksize.
In the inner loop, iterate over the column given by colname in chunk by using a for loop. Use the loop variable entry.
Call the count_entries() function by passing to it the filename 'tweets.csv', the size of chunks 10, and the name of the column to count, 'lang'. Assign the result of the call to the variable result_counts.


# Define count_entries()
def count_entries(csv_file, c_size, colname):
    """Return a dictionary with counts of
    occurrences as value for each key."""
    
    # Initialize an empty dictionary: counts_dict
    counts_dict = {} # set empty dictionary through dic = {}

    # Iterate over the file chunk by chunk
    for chunk in pd.read_csv(csv_file, chunksize=c_size):

        # Iterate over the column in DataFrame
        for entry in chunk[colname]:
            if entry in counts_dict.keys():
                counts_dict[entry] += 1
            else:
                counts_dict[entry] = 1

    # Return counts_dict
    return counts_dict

# Call count_entries(): result_counts
result_counts = count_entries('tweets.csv', 10, 'lang')

# Print result_counts
print(result_counts)






############################################ Course 2: List comprehensions and generators ############################################

List comprehension

populate a list with a for loop:
nums=[12,8,21,3,16]
new_nums=[]
for num in nums:
    new_nums.append(num+1)
    
 --> do this in one line of code
 
 a list comprehension:
nums=[12,8,21,3,16]
new_nums= [num + 1 for num in nums]


List comprehension with Range()

result = [num for num in range(11)
--> [0,1,2,...,10]

List comprehension:
1. collapes for loops for building lists into a single line
2. components: iterable, iterator variable, output expression

Nested loops:
pairs_1=[]
for num1 in range(0,2)
    for num2 in range(6,8)
        pairs_1.append(num1,num2)
 print(pairs_1)
 --> [(0,6),(0,7),(1,6),(1,7)]
 
 pairs_2=[(num1,num2) for num1 in range(0,2) for num2 in range(6,8)]
 
 
 # Create a 5 x 5 matrix using a list of lists: matrix
# In the inner list comprehension - that is, the output expression of the nested list comprehension 
# - create a list of values from 0 to 4 using range(). Use col as the iterator variable.
 matrix = [[col for col in range(5)] for row in range(5)]
 
 
 
 
Advanced comprehensions

conditionals in comprehensions:
[num ** 2 for num in range(10) if num % 2 == 0] # % is the modulo operator

# Use member as the iterator variable in the list comprehension. 
# For the conditional, use len() to evaluate the iterator variable. Note that you only want strings with 7 characters or more.
# Create list comprehension: new_fellowship
new_fellowship = [member for member in fellowship if len(member) >= 7]

# In the output expression, keep the string as-is if the number of characters is >= 7, 
# else replace it with an empty string - that is, '' or "".
new_fellowship = [member if len(member) >= 7 else '' for member in fellowship]



Dict comprehensions:
create dictionaries
use curly braces {} instead of bracket []
pos_neg ={num: - num for num in range(9)}

# Create dict comprehension: new_fellowship
new_fellowship = { member: len(member) for member in fellowship }



generator expressions

List comprehension vs. generators
- list comprehension - returns a list
- generators - returns a generator object
- both can be iterated over































