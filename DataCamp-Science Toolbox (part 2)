Python Data Science Toolbox (Part 2)

summary

Create a range object that would produce the values from 10 to 20 using range(). Assign the result to values
values = range(10, 21) --> should be x: y-1

Generator
Generator functions allow you to declare a function that behaves like an <iterator>, i.e. it can be used in a for loop.




############################################ Course 1: Using iterators in PythonLand ############################################

iterating with a for loop:
for letter in 'DataCamp':
    print (letter)
    
for i in range(4):
    print(i)
    
Iterators vs. iterables
- iterable:
   example" lists, strings, dictionaries, file connections
   An objective with an associated iter() method
   Apply .iter() to an iterable creates an iterator
- iterator:
   produces next value with next()
   
iterating over iterables: next()
word='Da'
it = iter(word)
next(it) -> D
next(it) -> a

iterating at once with *
word = ' Data'
it=iter(word)
print(*it) -> D a t a
-- once you do so, you cannot do it again. For example, you call print(*it) for the second time, nothing will be outputted.

iterating over dictionaries: [ unpack the dictionary, through .item() ]
pythonistas={'hugo':'bown','francis':'castro'}
for key,value in pythonistas.items(): --> unpack them
    print(key,value)
-> francis castro
   hugo bown


iterating over file connections
file = open('file.txt')
it=iter(file)
print(next(it))
--> this is the first line.



# Create a list of strings: flash
flash = ['jay garrick', 'barry allen', 'wally west', 'bart allen']

# Print each list item in flash using a for loop
for person in flash:
    print(person)

# Create an iterator for flash: superhero
superhero = iter(flash)

# Print each item from the iterator
print(next(superhero))
print(next(superhero))
print(next(superhero))
print(next(superhero))



# Create an iterator for range(3): small_value
small_value = iter(range(3))

# Print the values in small_value
print(next(small_value))
print(next(small_value))
print(next(small_value))

# Loop over range(3) and print the values
for num in range(3):
    print(num)


# Create an iterator for range(10 ** 100): googol
googol = iter(range(10 ** 100))



Create a range object that would produce the values from 10 to 20 using range(). Assign the result to values
values = range(10, 21) --> should be x: y-1






Playing with iterators

using enumerate()
enumerate(iterable, start=0)
The enumerate() method adds a counter to an iterable and returns it (the enumerate object).
-- iterable - a sequence, an iterator, or objects that supports iteration
-- start (optional) - enumerate() starts counting from this number. If start is omitted, 0 is taken as start.

avengers =['hawkeye','iron men','thor','quicksilver']
e = enumerator(avengers)
print(type(e))
--> <class 'enumerate'>
# convert enumerate object to list
e_list=list(e)
print(e_list)
---> [(0,'hawkeye'),(1,'iron men'),(2,'thor'),(3,'quicksilver')]



enumerate() and unpack

avengers =['hawkeye','iron men','thor','quicksilver']
for index, value in enumerate(avengers):
    print(index,value)
--> 0 hawkeye
    1 iron men
    2 thor
    3 quicksilver
    

Complete the first for loop by unpacking the tuples generated by calling enumerate() on mutants. 
Use index1 for the index and value1 for the value when unpacking the tuple.
# Unpack and print the tuple pairs
for index1,value1 in enumerate(mutants):
    print(index1, value1)

Complete the second for loop similarly as with the first, but this time change the starting index to start from 1 
by passing it in as an argument to the start parameter of enumerate(). Use index2 for the index and value2 for the value when unpacking the tuple.
# Change the start index
for index2, value2 in enumerate(mutants,1):
    print(index2, value2)
    
    






using zip()
Join two tuples together:
The zip() function takes iterables (can be zero or more), aggregates them in a tuple, and returns it.
zip(*iterables)
can be built-in iterables (like: list, string, dict), or user-defined iterables

avengers =['hawkeye','iron men','thor','quicksilver']
names = ['barton','stark','odinson','maxmoff']
z = zip(avengers,names)
print(type(z))
--> < class 'zip' >
z_list=list(z)
print(z_list)
--> [('hawkeye','barton'),('iron man','stark'),('thor','odinson'),('quicksilver','maximoff')]
for z1,z2 in zip(avengers,names):
    print(z1,z2)
---> hawkeye barton
     iron man stark
     thor odinson
     quicksilver maximoff




# Create a list of tuples: mutant_data
Using zip() with list(), create a list of tuples from the three lists mutants, aliases, and powers (in that order) and assign the result to mutant_data.
mutant_data = list(zip(mutants, aliases, powers))

# Create a zip object using the three lists: mutant_zip
Using zip(), create a zip object called mutant_zip from the three lists mutants, aliases, and powers.
mutant_zip = zip(mutants, aliases, powers)

# Unpack the zip object and print the tuple values
for value1, value2, value3 in mutant_zip:
    print(value1, value2, value3)
    




------------ Chunk 
    
Sometimes, the data we have to process reaches a size that is too much for a computer's memory to handle. This is a common problem faced by data scientists. 
A solution to this is to process an entire data source chunk by chunk, instead of a single go all at once.

Using iterators to load large files into memory

loading data in chunks
- there acan be too much data to hold in memory
- solution: load data in chunks!
- pandas function: pd.read_csv()
- - specify the chunk: chunk_size


Iterating over data

import pandas as pd
result =[]
for chunk in pd.read_csv('data.csv',chunksize=1000):
    result.append(sum(chunk['x']))
total = sum(result)
print(total)

import pandas as pd
total = 0
for chunk in pd.read_csv('data.csv',chunksize=1000):
    total += sum(chunk['x'])
print(total)


    
# Initialize an empty dictionary: counts_dict
counts_dict={}

# Iterate over the 'tweets.csv' file by using a for loop. Use the loop variable chunk and iterate over the call to pd.read_csv() with a chunksize of 10.
for chunk in pd.read_csv('tweets.csv',chunksize = 10):

    # In the inner loop, iterate over the column 'lang' in chunk by using a for loop. Use the loop variable entry.
    for entry in chunk['lang']:
        if entry in counts_dict.keys():
            counts_dict[entry] += 1
        else:
            counts_dict[entry] = 1






Exercise:
Define the function count_entries(), which has 3 parameters. The first parameter is csv_file for the filename, the second is c_size for the chunk size, and the last is colname for the column name.
Iterate over the file in csv_file file by using a for loop. Use the loop variable chunk and iterate over the call to pd.read_csv(), passing c_size to chunksize.
In the inner loop, iterate over the column given by colname in chunk by using a for loop. Use the loop variable entry.
Call the count_entries() function by passing to it the filename 'tweets.csv', the size of chunks 10, and the name of the column to count, 'lang'. Assign the result of the call to the variable result_counts.


# Define count_entries()
def count_entries(csv_file, c_size, colname):
    """Return a dictionary with counts of
    occurrences as value for each key."""
    
    # Initialize an empty dictionary: counts_dict
    counts_dict = {} # set empty dictionary through dic = {}

    # Iterate over the file chunk by chunk
    for chunk in pd.read_csv(csv_file, chunksize=c_size):

        # Iterate over the column in DataFrame
        for entry in chunk[colname]:
            if entry in counts_dict.keys():
                counts_dict[entry] += 1
            else:
                counts_dict[entry] = 1

    # Return counts_dict
    return counts_dict

# Call count_entries(): result_counts
result_counts = count_entries('tweets.csv', 10, 'lang')

# Print result_counts
print(result_counts)






############################################ Course 2: List comprehensions and generators ############################################

List comprehension

populate a list with a for loop:
nums=[12,8,21,3,16]
new_nums=[]
for num in nums:
    new_nums.append(num+1)
    
 --> do this in one line of code
 
 a list comprehension:
nums=[12,8,21,3,16]
new_nums= [num + 1 for num in nums]


List comprehension with Range()

result = [num for num in range(11)
--> [0,1,2,...,10]

List comprehension:
1. collapes for loops for building lists into a single line
2. components: iterable, iterator variable, output expression

Nested loops:
pairs_1=[]
for num1 in range(0,2)
    for num2 in range(6,8)
        pairs_1.append(num1,num2)
 print(pairs_1)
 --> [(0,6),(0,7),(1,6),(1,7)]
 
 pairs_2=[(num1,num2) for num1 in range(0,2) for num2 in range(6,8)]
 
 
 # Create a 5 x 5 matrix using a list of lists: matrix
# In the inner list comprehension - that is, the output expression of the nested list comprehension 
# - create a list of values from 0 to 4 using range(). Use col as the iterator variable.
 matrix = [[col for col in range(5)] for row in range(5)]
 
 
 
 
Advanced comprehensions

conditionals in comprehensions:
[num ** 2 for num in range(10) if num % 2 == 0] # % is the modulo operator

# Use member as the iterator variable in the list comprehension. 
# For the conditional, use len() to evaluate the iterator variable. Note that you only want strings with 7 characters or more.
# Create list comprehension: new_fellowship
new_fellowship = [member for member in fellowship if len(member) >= 7]

# In the output expression, keep the string as-is if the number of characters is >= 7, 
# else replace it with an empty string - that is, '' or "".
new_fellowship = [member if len(member) >= 7 else '' for member in fellowship]



Dict comprehensions:
create dictionaries
use curly braces {} instead of bracket []
pos_neg ={num: - num for num in range(9)}

# Create dict comprehension: new_fellowship
new_fellowship = { member: len(member) for member in fellowship }



generator expressions

List comprehension vs. generators
- list comprehension - returns a list
- generators - returns a generator object
- both can be iterated over




Introduction to generator expressions 

List comprehensions vs. generators
- list comprehension - return a list
- generators - return a generator object
- both a iterated over



# Create a list of strings
lannister = ['cersei', 'jaime', 'tywin', 'tyrion', 'joffrey']

# Define generator function get_lengths
def get_lengths(input_list):
    """Generator function that yields the
    length of the strings in input_list."""

    # Yield the length of a string
    for person in input_list:
        yield len(person)  # yield the length of the strings in input_list
        
-- yield is a keyword that is used like return, except the function will return a generator

# Print the values generated by get_lengths()
for value in get_lengths(lannister):
    print(value)
    
    



Wrapping up comprehensions and generators.

re-cap: list comprehensions
- basic: 
[ output expression for iterator variable in iterable]
- Advanced:
[ output expression +
  conditional on output for iterator variable in iterable +
  conditional on iterable ]
  
  










############################################ Course 3: Bringing it all together! ############################################

Using zip()

the zip function accepts an arbitary number of iterables and returns an iterator of tuples
a=['','','']
b=['','','']
z = zip(a,b)
print(list(z))



Inspect the contents of row_lists by printing the first two lists in row_lists.
# Print the first two lists in row_lists
print(row_lists[0])
print(row_lists[1])

# !!!! Turn list of lists into list of dicts: list_of_dicts !!!!!!!
list_of_dicts = [lists2dict(feature_names, sublist) for sublist in row_lists]

Look at the first two dictionaries in list_of_dicts by printing them out.
# Print the first two dictionaries in list_of_dicts
print(list_of_dicts[0])
print(list_of_dicts[1])


# Turn list of dicts into a DataFrame: df
df = pd.DataFrame(list_of_dicts)

# Print the head of the DataFrame
print(df.head())






Using Python generators for streaming data
For large data:  build a generator function

# Open a connection to the file
with open('world_dev_ind.csv') as file:

    # Skip the column names
    file.readline()

    # Initialize an empty dictionary: counts_dict
    counts_dict = {}

    # Process only the first 1000 rows
    for j in range(1000):

        # Split the current line into a list: line
        line = file.readline().split(',')

        # Get the value for the first column: first_col
        first_col = line[0]

        # If the column value is in the dict, increment its value
        if first_col in counts_dict.keys():
            counts_dict[first_col] += 1

        # Else, add to the dict and set value to 1
        else:
            counts_dict[first_col] = 1

# Print the resulting dictionary
print(counts_dict)







# Define read_large_file()
def read_large_file(file_object):
    """A generator function to read a large file lazily."""

    # Loop indefinitely until the end of the file
    while True:

        # Read a line from the file: data
        data = file_object.readline()

        # Break if this is the end of the file
        if not data:
            break

        # Yield the line of data
        yield data

# Open a connection to the file
with open('world_dev_ind.csv') as file:

    # Create a generator object for the file: gen_file
    gen_file = read_large_file(file)

    # Print the first three lines of the file
    print(next(gen_file))
    print(next(gen_file))
    print(next(gen_file))
    
    
    
    Hint:
    To apply a method x() to an object y, do: y.x().





    
Using pandas' read_csv iterator for streaming data

read_csv has a parameter called [chunksize]! 
The parameter essentially means the number of rows to be read into a dataframe at any single time in order to 
fit into the local memory.

Reading files in chunks
- up next
     read_csv() function and chunksize argument


# Initialize reader object: df_reader
df_reader = pd.read_csv('ind_pop.csv', chunksize= 10)





Write a list comprehension to generate a list of values from pops_list for the new column 'Total Urban Population'. 
The output expression should be the product of the first and second element in each tuple in pops_list. 
Because the 2nd element is a percentage, you also need to either multiply the result by 0.01 or divide it by 100. 
In addition, note that the column 'Total Urban Population' should only be able to take on integer values. 
To ensure this, make sure you cast the output expression to an integer with int().

df_pop_ceb['Total Urban Population'] = [int(tup[0] * tup[1] * 0.01) for tup in pops_list]






# Initialize reader object: urb_pop_reader
urb_pop_reader = pd.read_csv('ind_pop_data.csv', chunksize=1000)

# Initialize empty DataFrame: data
data = pd.DataFrame()

# Iterate over each DataFrame chunk
for df_urb_pop in urb_pop_reader:  --> There is no ()

    # Check out specific country: df_pop_ceb
    df_pop_ceb = df_urb_pop[df_urb_pop['CountryCode'] == 'CEB']

    # Zip DataFrame columns of interest: pops
    pops = zip(df_pop_ceb['Total Population'],
                df_pop_ceb['Urban population (% of total)'])

    # Turn zip object into list: pops_list
    pops_list = list(pops)

    # Use list comprehension to create new DataFrame column 'Total Urban Population'
    df_pop_ceb['Total Urban Population'] = [int(tup[0] * tup[1] * 0.01) for tup in pops_list]
    
    # Append DataFrame chunk to data: data
    data = data.append(df_pop_ceb)

# Plot urban population data
data.plot(kind='scatter', x='Year', y='Total Urban Population')
plt.show()





# Define plot_pop()
def plot_pop(filename, country_code):

    # Initialize reader object: urb_pop_reader
    urb_pop_reader = pd.read_csv(filename, chunksize=1000)

    # Initialize empty DataFrame: data
    data = pd.DataFrame()
    
    # Iterate over each DataFrame chunk
    for df_urb_pop in urb_pop_reader:
        # Check out specific country: df_pop_ceb
        df_pop_ceb = df_urb_pop[df_urb_pop['CountryCode'] == country_code]

        # Zip DataFrame columns of interest: pops
        pops = zip(df_pop_ceb['Total Population'],
                    df_pop_ceb['Urban population (% of total)'])

        # Turn zip object into list: pops_list
        pops_list = list(pops)

        # Use list comprehension to create new DataFrame column 'Total Urban Population'
        df_pop_ceb['Total Urban Population'] = [int(tup[0] * tup[1] * 0.01) for tup in pops_list]
    
        # Append DataFrame chunk to data: data
        data = data.append(df_pop_ceb)

    # Plot urban population data
    data.plot(kind='scatter', x='Year', y='Total Urban Population')
    plt.show()

# Set the filename: fn
fn = 'ind_pop_data.csv'

# Call plot_pop for country code 'CEB'
plot_pop(fn, 'CEB')

# Call plot_pop for country code 'ARB'
plot_pop(fn, 'ARB')
