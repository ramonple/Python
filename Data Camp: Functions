
##################################### Course 1: Best Practices #####################################
Docstrings
-- A Python docstring is a string used to document a Python module, class, function or method, 
so programmers can understand what it does without having to read the details of the implementation. 

# define a function to calculate the letter

def count_letter(content, letter):
  """Count the number of times `letter` appears in `content`.
  # Add a Google-style arguments section
  Args:
    content (str): The string to search.
    letter (str): The letter to search for
    
  # Add a returns section
  Returns:
    int
    
  # Add a section detailing what errors might be raised
  Raises:
    ValueError: If `letter` is not a one-character string
  """
  if (not isinstance(letter, str)) or len(letter) != 1: ---> The isinstance() function returns True if the specified object is of the specified type, otherwise False.
    raise ValueError('`letter` must be a single character string.')
    return len([char for char in content if char == letter])


Retrieving docstrings

1. # Begin by getting the docstring for the function count_letter(). Use an attribute of the count_letter() function.
# Get the "count_letter" docstring by using an attribute of the function
docstring = count_letter.__doc__

border = '#' * 28
print('{}\n{}\n{}'.format(border, docstring, border))

2. # Now use a function from the inspect module to get a better-formatted version of count_letter()'s docstring.
import inspect
# Inspect the count_letter() function to get its docstring
docstring = inspect.getdoc(count_letter)

border = '#' * 28
print('{}\n{}\n{}'.format(border, docstring, border))


3. # Now create a build_tooltip() function that can extract the docstring from any function that we pass to it.
import inspect

def build_tooltip(function):
  """Create a tooltip for any function that shows the
  function's docstring.

  Args:
    function (callable): The function we want a tooltip for.

  Returns:
    str
  """
  # Get the docstring for the "function" argument by using inspect
  docstring = inspect.getdoc(function)
  border = '#' * 28
  return '{}\n{}\n{}'.format(border, docstring, border)

print(build_tooltip(count_letter))
print(build_tooltip(range))
print(build_tooltip(print))



numpy.fywdkxa() is actually numpy.histogram() in disguise




DRY and "Do One Thing"
DRY Don't Repeat Yourself


def load_data(path):
    data=pd.read_csv(path)
    y=data['labels'].values
    X=data[col for col in data.columns
               if col ! = 'labels].values
    return X,y

def plot_data(X)
    pca=PCA(n_components=2).fit_transform(X)
    plt.scatterplot(pca[:,0],pca[:,1])
    
    

-- exercise
def standardize(column):
  """Standardize the values in a column.

  Args:
    column (pandas Series): The data to standardize.

  Returns:
    pandas Series: the values as z-scores
  """
  # Finish the function so that it returns the z-scores
  z_score = (column - column.mean()) / column.std() --> directly column, not df.column or df['column']
  return z_score

# Use the standardize() function to calculate the z-scores
df['y1_z'] = standardize(df.y1_gpa)
df['y2_z'] = standardize(df.y2_gpa)
df['y3_z'] = standardize(df.y3_gpa)
df['y4_z'] = standardize(df.y4_gpa)

-- function for median
def median(values):
  """Get the median of a sorted list of values

  Args:
    values (iterable of float): A list of numbers

  Returns:
    float
  """
  # Write the median() function
  midpoint = int(len(values) / 2)
  if len(values) % 2 == 0:
    median = (values[midpoint - 1] + values[midpoint]) / 2
  else:
    median = values[midpoint]
  return median
  
  
  
  
  
  Pass by assignment
Immutable:
int, float, bool, string, bytes, tuple, frozenset, Non
Mutable:
list, dict, set, bytearray, objects, functions, almost everthing else

-- exercise
# Use an immutable variable for the default argument
def better_add_column(values, df=None):
  """Add a column of `values` to a DataFrame `df`.
  The column will be named "col_<n>" where "n" is
  the numerical index of the column.

  Args:
    values (iterable): The values of the new column
    df (DataFrame, optional): The DataFrame to update.
      If no DataFrame is passed, one is created by default.

  Returns:
    DataFrame
  """
  # Update the function to create a default DataFrame
  if df is None:
    df = pandas.DataFrame()
  df['col_{}'.format(len(df.columns))] = values
  return df
   
##################################### Course 2: Context Managers #####################################

Context managers allow you to allocate and release resources precisely when you want to.
The most widely used example of context managers is the < with > statement. 
Suppose you have two related operations which youâ€™d like to execute as a pair, with a block of code in between.
Context managers allow you to do specifically that. For example:

with open('some_file', 'w') as opened_file:
    opened_file.write('Hola!')

# The above code opens the file, writes some data to it and then closes it. 
If an error occurs while writing the data to the file, it tries to close it. The above code is equivalent to:

file = open('some_file', 'w')
try:
    file.write('Hola!')
finally:
    file.close()

------------------------------------------------------------------------
1. Using context managers

with open('my_file.txt') as my_file: ---> with xxx as xxx:
     # this code is running inside the context
     text = my_file.read()
     length = len(text)
# this code runs after the context is removed
print('The file is {} characters long'.format(length))

     

2. Writing context managers
a. class-based
b. function-based *

Steps:
1. define a function
2. (optinal) add any set up code you context needs
3. use the 'yield' keywords
4. (optional) addd any teardown code your context need
5. add the '@contextlib.contextmanager' decorator

@contextlib.contextmanager
def my_context()
   # add any set up code you need
   print('hello')
   yield 42
   # add any teardown code you neeed
   print('goodby')
   
with my_context() as foo:
     print('foo is{}'.format(foo))


--> hello
    foo is 42
    bye
    
    

@contextlib.contextmanager
def database(r):
    # set up the database connection
    db=postgres.connect(url)
    yield db
    $ tear down database connection
    db.disconnect()
url ='http:xxxx'
with database(url) as my_db
     course_list = my_db.exexcute('select * from courses')


# Add a decorator that will make timer() a context manager
@contextlib.contextmanager
def timer():
  """Time the execution of a context block.

  Yields:
    None
  """
  start = time.time()
  # Send control back to the context block
  yield
  end = time.time()
  print('Elapsed: {:.2f}s'.format(end - start))

with timer():
  print('This should take approximately 0.25 seconds')
  time.sleep(0.25)


@contextlib.contextmanager
def open_read_only(filename):
  """Open a file in read-only mode.

  Args:
    filename (str): The location of the file to read

  Yields:
    file object
  """
  read_only_file = open(filename, mode='r') -- takes a filename and a mode ('r' for read, 'w' for write, or 'a' for append)
  # Yield read_only_file so it can be assigned to my_file
  yield read_only_file -- yields control back to the context, along with a reference to the file
  # Close read_only_file
  read_only_file.close()

with open_read_only('my_file.txt') as my_file:
  print(my_file.read())
  
  
  
 
 
Advanced topics
def copy(src,dst):
    with open(src) as f_src:
         contents = f_src.read()
    
    with open(dst,'w') as f_dst:
        f_dst.write(contents)
        
        
Nested contexts

def copy(src,dst):
    with open(src) as f_src:
       with open(dst,'w') as f_dst:
           # read and write each line, one at a time
           for line in f_src:
               f_dst.write(line)

     
Handling errors:

try:
   # code that might raises an error
except:
  # do something about the error
finally:
  # this code runs no matter what
  
  

# Use the "stock('NVDA')" context manager
# and assign the result to the variable "nvda"
with stock('NVDA') as nvda:
  # Open 'NVDA.txt' for writing as f_out
  with open('NVDA.txt', 'w') as f_out:
    for _ in range(10):
      value = nvda.price()
      print('Logging ${:.2f} for NVDA'.format(value))
      f_out.write('{:.2f}\n'.format(value))




def in_dir(directory):
  """Change current working directory to `directory`,
  allow the user to run some code, and change back.

  Args:
    directory (str): The path to a directory to work in.
  """
  current_dir = os.getcwd()
  os.chdir(directory)

  # Add code that lets you handle errors
  try:
    yield
  # Ensure the directory is reset,
  # whether there was an error or not
  finally:
    os.chdir(current_dir)
    
    
   
##################################### Course 3: Decorators #####################################

1. Functions are objects

list_of_functions=[my_function, open, print]
list_of_funtions[2]('I am printing with an element of list') --> the third element


dict_of_functions = {
   'func1':my_function,
   'func2':open,
   'func3':print
   }
dict_of_functions['func3']('I am printing with a value of a dict!')



----- Defining a function inside another function
def foo(x,y):
   def in_range(v):
       return v>4 and v<10
       
   if in_range(x) and in_range(y):
      print(x*y)


# Add the missing function references to the function map
function_map = {
  'mean': mean,
  'std': std,
  'minimum': minimum,
  'maximum': maximum
}

data = load_data()
print(data)

func_name = get_user_input()

# Call the chosen function and pass "data" as an argument
function_map[func_name](data)      
      
      
-- has_docstring(function_name)
  a string used to document a Python module, class, function or method, so programmers can understand 
  what it does without having to read the details of the implementation

# Call has_docstring() on the load_and_plot_data() function
ok = has_docstring(load_and_plot_data)

# Call has_docstring() on the as_2D() function
ok = has_docstring(as_2D)


def create_math_function(func_name):
  if func_name == 'add':
    def add(a, b):
      return a + b
    return add
  elif func_name == 'subtract':
    # Define the subtract() function
    def subtract(a,b):
      return a - b
    return subtract
  else:
    print("I don't know that one")
    
add = create_math_function('add')
print('5 + 2 = {}'.format(add(5, 2)))

subtract = create_math_function('subtract')
print('5 - 2 = {}'.format(subtract(5, 2)))







--------- 2. Scope
Scope determines which variables can be accessed at different points in your code.

Builtin > Global > nonlocal > Local


def wait_until_done():
  def check_is_done():
    # Add a keyword so that wait_until_done() 
    # doesn't run forever
    global done
    if random.random() < 0.1:
      done = True
      
  while not done:
    check_is_done()

done = False
wait_until_done()

print('Work done? {}'.format(done))




-----  3. Closures

< FunctionName.__closure__ >
< my_func.__closure__[i].cell_contents >

A closure in Python is a tuple of variables that are no longer in scope, but that a function needs in order to run.

Nonlocal variable: Variables defined in the parent function that are used by the child function.

def parent(arg_1,arg_2)"
    value = 22
    my_dict = {'chocolate':'yummy'}
    
def child():
    print(2*value)
    print(my_dict['chocolate'])
    print(arg_1 + arg_2)
    
return child

new_function = parent(3,4)

print([cell.cell_contents for cell in new_function.__closure__])




def return_a_func(arg1, arg2):
  def new_func():
    print('arg1 was {}'.format(arg1))
    print('arg2 was {}'.format(arg2))
  return new_func
    
my_func = return_a_func(2, 17)

# Show that my_func()'s closure is not None
print(my_func.__closure__ is not None) ---> Notice!!!!! functionName.__closure__

# Show that there are two variables in the closure
print(len(my_func.__closure__) == 2)

# Get the values of the variables in the closure
closure_values = [
  my_func.__closure__[i].cell_contents for i in range(2)
]
print(closure_values == [2, 17])




---- 4. Decorators

modify the inputs, modify the outputs, and also modify the function's behavior

@double_args
def multiply(a,b):
    return a*b
def double_args(func):
    # define a new function that we can modify
    def wrapper(a,b):
        return func(a,b)
    return wrapper
    
    
    
def my_function(a, b, c):
  print(a + b + c)

# Decorate my_function() with the print_args() decorator
my_function = print_args(my_function)

my_function(1, 2, 3)


# Decorate my_function() with the print_args() decorator
@print_args
def my_function(a, b, c):
  print(a + b + c)

my_function(1, 2, 3)



def print_before_and_after(func):
  def wrapper(*args):
    print('Before {}'.format(func.__name__))
    # Call the function being decorated with *args
    func(*args)
    print('After {}'.format(func.__name__))
  # Return the nested function
  return wrapper

@print_before_and_after
def multiply(a, b):
  print(a * b)

multiply(5, 10)




##################################### Course 4: More on Decorators #####################################
